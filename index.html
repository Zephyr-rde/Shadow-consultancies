<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Portfolio - Ray</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=Montserrat:wght@300;400;600;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
   <link rel="stylesheet" href="index.css">
</head>
<body>
    <!-- Loading Screen -->
    <div class="loader">
        <div class="loader-spinner"></div>
    </div>

    <!-- Lotus Background -->
    <div class="lotus-background">
        <canvas id="lotusCanvas"></canvas>
    </div>
    
    <!-- Floating particles container -->
    <div id="particles-container"></div>
    
    <!-- Blood drips container -->
    <div id="blood-container"></div>
    
    <!-- Header -->
    <header>
        <div class="logo-container">
            <div class="logo">Ray</div>
        </div>
    </header>
    
    <!-- Main Content -->
    <div class="container">
        <div class="content-box">
            <h1 class="title">My Portfolio</h1>
            <p class="subtitle">Innovation, Creativity &amp; Technical Excellence</p>
            
            <h3 class="version-title">Explore My Projects</h3>
            <div class="buttons">
                <a href="homepage.html" class="btn" style="--i: 1">
                    <i class="fas fa-gem btn-icon"></i>
                    <span class="btn-text">Version 1</span>
                    <span class="btn-subtext">Classic Interface</span>
                </a>
                <a href="homepage2.html" class="btn" style="--i: 2">
                    <i class="fas fa-rocket btn-icon"></i>
                    <span class="btn-text">Version 2</span>
                    <span class="btn-subtext">Modern Interface</span>
                </a>
                <a href="Atheeq.html" class="btn" style="--i: 3">
                    <i class="fas fa-leaf btn-icon"></i>
                    <span class="btn-text">Ecofertilize</span>
                    <span class="btn-subtext">Friendly Interface</span>
                </a>
                <a href="Atheeq2.html" class="btn" style="--i: 4">
                    <i class="fas fa-seedling btn-icon"></i>
                    <span class="btn-text">Ecogrow</span>
                    <span class="btn-subtext">Hightech Interface</span>
                </a>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <footer>
        <p>Â© 2025 Ray's Portfolio | All Rights Reserved</p>
    </footer>

    <script>
    // Initialize the lotus background when the document is loaded
    document.addEventListener('DOMContentLoaded', function() {
        initLotusBackground();
    });
    
    // Hide loader when the page is fully loaded
    window.addEventListener('load', function() {
        const loader = document.querySelector('.loader');
        if (loader) {
            loader.style.display = 'none';
        }
    });
    
    function initLotusBackground() {
        const canvas = document.getElementById('lotusCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Background lotuses - evenly distributed
        const lotusCount = 12;
        const lotuses = [];
        
        // Grid spacing for even distribution
        const gridCols = 4;
        const gridRows = 3;
        const cellWidth = canvas.width / gridCols;
        const cellHeight = canvas.height / gridRows;
        
        // Create evenly distributed lotuses
        for (let row = 0; row < gridRows; row++) {
            for (let col = 0; col < gridCols; col++) {
                const baseX = cellWidth * col + cellWidth / 2;
                const baseY = cellHeight * row + cellHeight / 2;
                
                // Add random variation within the cell
                const x = baseX + (Math.random() - 0.5) * cellWidth * 0.5;
                const y = baseY + (Math.random() - 0.5) * cellHeight * 0.5;
                
                lotuses.push({
                    x: x,
                    y: y,
                    scale: 0.4 + Math.random() * 0.4,
                    rotation: Math.random() * Math.PI * 2,
                    petals: [],
                    petalCount: 10 + Math.floor(Math.random() * 6),
                    bloomSpeed: 0.5 + Math.random() * 0.5,
                    bloomPhase: Math.random() * Math.PI * 2,
                    ripples: [],
                    color: Math.random() > 0.7 ? 'darkred' : 'bloodred',
                    isCenter: false,
                    z: Math.random() * 200 - 100, // 3D depth
                    depthPhase: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Add the large black lotus in the center - now more ominous
        const centerLotus = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            scale: 1.8, // Larger for more dominance
            rotation: 0,
            petals: [],
            petalCount: 18, // More petals for complexity
            bloomSpeed: 0.25, // Slower, more hypnotic bloom
            bloomPhase: 0,
            ripples: [],
            color: 'void', // Even darker than black
            isCenter: true,
            pulsePhase: 0,
            energyWaves: [], // New effect
            symbols: Array(5).fill().map(() => ({
                opacity: 0,
                rotation: Math.random() * Math.PI * 2,
                scale: 0,
                type: Math.floor(Math.random() * 3)
            })),
            z: 50 // Always in front
        };
        
        lotuses.push(centerLotus);
        
        // Create petals with 3D effects
        lotuses.forEach(lotus => {
            for (let i = 0; i < lotus.petalCount; i++) {
                const angle = (i / lotus.petalCount) * Math.PI * 2;
                lotus.petals.push({
                    angle,
                    length: (150 + Math.random() * 30) * lotus.scale,
                    width: (70 + Math.random() * 20) * lotus.scale,
                    offset: Math.random() * 1000,
                    curve: 0.3 + Math.random() * 0.2,
                    heightMap: Array(5).fill().map(() => Math.random() * 0.5 + 0.5), // 3D height map
                    shimmerPhase: Math.random() * Math.PI * 2,
                    shimmerSpeed: Math.random() * 0.02 + 0.01
                });
            }
            
            // Create initial ripples
            if (!lotus.isCenter) {
                for (let i = 0; i < 3; i++) {
                    createRipple(lotus);
                }
            } else {
                // More ripples for center lotus
                for (let i = 0; i < 8; i++) {
                    createRipple(lotus, true);
                }
                
                // Create energy waves for center lotus
                for (let i = 0; i < 3; i++) {
                    createEnergyWave(lotus);
                }
            }
        });
        
        function createEnergyWave(lotus) {
            lotus.energyWaves.push({
                radius: 10 * lotus.scale,
                maxRadius: (150 + Math.random() * 100) * lotus.scale,
                thickness: (3 + Math.random() * 3) * lotus.scale,
                speed: (0.8 + Math.random() * 0.7) * lotus.scale,
                opacity: 0.7 + Math.random() * 0.3,
                hue: Math.random() * 60, // Red to dark red
                pattern: Math.floor(Math.random() * 3) // Different wave patterns
            });
        }
        
        function createRipple(lotus, isOminous = false) {
            const distance = Math.random() * 100 * lotus.scale + 50 * lotus.scale;
            const angle = Math.random() * Math.PI * 2;
            
            const ripple = {
                x: lotus.x + Math.cos(angle) * distance,
                y: lotus.y + Math.sin(angle) * distance,
                radius: 5 * lotus.scale,
                maxRadius: (30 + Math.random() * 50) * lotus.scale,
                speed: (0.5 + Math.random() * 0.5) * lotus.scale,
                opacity: 0.8,
                color: isOminous ? '#330000' : undefined,
                pulsePhase: Math.random() * Math.PI * 2,
                // Distortion for unsettling effect
                distort: isOminous ? {
                    amount: 0.2 + Math.random() * 0.3,
                    frequency: 3 + Math.random() * 5,
                    speed: 0.01 + Math.random() * 0.02
                } : null
            };
            
            lotus.ripples.push(ripple);
        }
        
        // Draw dark water background with more depth and movement
        function drawWater(time) {
            // Create a very dark background gradient with subtle movement
            const offset = Math.sin(time / 10000) * canvas.width * 0.1;
            
            const gradient = ctx.createLinearGradient(offset, 0, canvas.width - offset, canvas.height);
            gradient.addColorStop(0, 'rgba(5, 0, 0, 1)');
            gradient.addColorStop(0.4, 'rgba(15, 0, 0, 0.95)');
            gradient.addColorStop(0.6, 'rgba(20, 0, 0, 0.9)');
            gradient.addColorStop(1, 'rgba(10, 0, 0, 0.95)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add subtle blood texture with depth and movement
            ctx.globalAlpha = 0.04;
            for (let i = 0; i < 25; i++) {
                const x = (Math.random() * canvas.width * 2 + time / (1000 + i * 100)) % (canvas.width * 1.5) - canvas.width * 0.25;
                const y = (Math.random() * canvas.height * 2 + time / (1500 + i * 150)) % (canvas.height * 1.5) - canvas.height * 0.25;
                const size = Math.random() * 400 + 100;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                
                // Create blood curdle effect
                if (i % 3 === 0) {
                    const bloodGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                    bloodGradient.addColorStop(0, 'rgba(120, 0, 0, 0.7)');
                    bloodGradient.addColorStop(0.3, 'rgba(70, 0, 0, 0.5)');
                    bloodGradient.addColorStop(0.7, 'rgba(40, 0, 0, 0.3)');
                    bloodGradient.addColorStop(1, 'rgba(20, 0, 0, 0)');
                    ctx.fillStyle = bloodGradient;
                } else {
                    ctx.fillStyle = i % 2 === 0 ? 'rgba(80, 0, 0, 0.5)' : 'rgba(40, 0, 0, 0.6)';
                }
                ctx.fill();
            }
            
            // Add deep, swirling abyss effect
            const abyssX = canvas.width / 2 + Math.sin(time/8000) * canvas.width * 0.1;
            const abyssY = canvas.height / 2 + Math.cos(time/7000) * canvas.height * 0.1;
            
            const abyssGradient = ctx.createRadialGradient(
                abyssX, abyssY, 0,
                abyssX, abyssY, canvas.height * 0.7
            );
            abyssGradient.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            abyssGradient.addColorStop(0.5, 'rgba(15, 0, 0, 0.2)');
            abyssGradient.addColorStop(0.8, 'rgba(5, 0, 0, 0.1)');
            abyssGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = abyssGradient;
            ctx.globalAlpha = 0.8 + Math.sin(time/5000) * 0.2;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1;
        }
        
        // Animation loop
        function animate() {
            // Update time
            time += 16;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update lotus centers with 3D movement
            lotuses.forEach(lotus => {
                if (!lotus.isCenter) {
                    // 3D floating motion
                    lotus.z += Math.sin(time / 4000 + lotus.depthPhase) * 0.5;
                    
                    // Calculate 3D projection scale
                    const depthScale = 1 + (lotus.z / 500); // -100 to 100 range
                    lotus.projectedScale = lotus.scale * depthScale;
                    
                    // Apply 3D motion
                    lotus.x += Math.sin(time / 3000 + lotus.bloomPhase) * 0.3 * depthScale;
                    lotus.y += Math.cos(time / 2800 + lotus.bloomPhase) * 0.2 * depthScale;
                    
                    // Keep lotuses on screen
                    if (lotus.x < -100) lotus.x = canvas.width + 100;
                    if (lotus.x > canvas.width + 100) lotus.x = -100;
                    if (lotus.y < -100) lotus.y = canvas.height + 100;
                    if (lotus.y > canvas.height + 100) lotus.y = -100;
                } else {
                    // Center lotus subtle movement
                    lotus.x = canvas.width / 2 + Math.sin(time / 9000) * 20;
                    lotus.y = canvas.height / 2 + Math.sin(time / 7000) * 15;
                    lotus.projectedScale = lotus.scale;
                    
                    // Update symbols
                    lotus.symbols.forEach(symbol => {
                        if (Math.random() < 0.005) {
                            symbol.opacity = 0.7 + Math.random() * 0.3;
                            symbol.scale = 0;
                        }
                        
                        if (symbol.opacity > 0) {
                            symbol.scale += (0.5 - symbol.scale) * 0.05;
                            symbol.opacity -= 0.005;
                            symbol.rotation += 0.01;
                        }
                    });
                }
            });
            
            // Draw the scene with enhanced darkness
            drawWater(time);
            
            // Sort lotuses by 3D depth
            lotuses.sort((a, b) => {
                // Always draw center lotus last (on top)
                if (a.isCenter) return 1;
                if (b.isCenter) return -1;
                return a.z - b.z;
            }).forEach(lotus => {
                // Calculate bloom factor with offset phase
                const normalizedTime = (time / (10000 * (lotus.isCenter ? 1.5 : 1)) + lotus.bloomPhase) % 1;
                let bloomFactor;
                
                if (lotus.isCenter) {
                    // More complex breathing pattern for center lotus
                    bloomFactor = 0.7 + Math.sin(time / 5000) * 0.1 + Math.sin(time / 7000) * 0.1 + Math.sin(time / 13000) * 0.1;
                } else if (normalizedTime < 0.5) {
                    // Opening phase (0 to 1)
                    bloomFactor = normalizedTime * 2;
                } else {
                    // Closing phase (1 to 0)
                    bloomFactor = 2 - normalizedTime * 2;
                }
                
                drawEnhancedLotus(lotus, bloomFactor, time);
                
                // Random chance to create new ripples
                if (Math.random() < 0.01) {
                    createRipple(lotus);
                } else if (lotus.isCenter && Math.random() < 0.05) {
                    createRipple(lotus, true);
                    
                    // Occasionally create energy wave
                    if (Math.random() < 0.3 && lotus.energyWaves.length < 8) {
                        createEnergyWave(lotus);
                    }
                }
            });
            
            // Continue animation loop
            requestAnimationFrame(animate);
        }
        
        // Enhanced lotus drawing with 3D effects and darkness
        function drawEnhancedLotus(lotus, bloomFactor, time) {
            const { x, y, color, isCenter, projectedScale } = lotus;
            const scale = projectedScale || lotus.scale;
            
            // Special effects for center lotus
            if (isCenter) {
                // Hypnotic pulsing glow
                lotus.pulsePhase += 0.01;
                const glowSize = 80 + Math.sin(lotus.pulsePhase) * 30 + Math.sin(lotus.pulsePhase * 0.5) * 20;
                
                // Draw dark vortex around center lotus
                const glow = ctx.createRadialGradient(
                    x, y, 10 * scale,
                    x, y, glowSize * scale
                );
                glow.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
                glow.addColorStop(0.4, 'rgba(30, 0, 0, 0.7)');
                glow.addColorStop(0.7, 'rgba(60, 0, 0, 0.4)');
                glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(x, y, glowSize * scale, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw energy waves (mystical aura)
                lotus.energyWaves.forEach((wave, index) => {
                    // Calculate wave distortion
                    const distortion = wave.pattern === 0 ? 
                        Math.sin(time / 1000 + wave.radius / 20) * 5 : 
                        wave.pattern === 1 ? 
                            Math.cos(time / 800) * 3 + Math.sin(time / 500) * 2 : 
                            0;
                    
                    ctx.beginPath();
                    
                    // Create jagged, mystical wave pattern
                    if (wave.pattern === 2) {
                        for (let i = 0; i < 36; i++) {
                            const angle = i * Math.PI / 18;
                            const radiusVariation = Math.sin(angle * 8 + time / 600) * (wave.thickness * 0.5);
                            const waveRadius = wave.radius + radiusVariation;
                            
                            const px = x + Math.cos(angle) * waveRadius;
                            const py = y + Math.sin(angle) * waveRadius;
                            
                            if (i === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                    } else {
                        ctx.arc(
                            x + Math.cos(time / 2000) * distortion, 
                            y + Math.sin(time / 1800) * distortion, 
                            wave.radius, 
                            0, 
                            Math.PI * 2
                        );
                    }
                    
                    // Wave color with subtle glow
                    const waveAlpha = wave.opacity * (1 - wave.radius / wave.maxRadius);
                    ctx.strokeStyle = `hsla(${wave.hue}, 100%, ${20 + (wave.pattern * 5)}%, ${waveAlpha})`;
                    ctx.lineWidth = wave.thickness * (0.7 + Math.sin(time / 1000 + wave.radius / 50) * 0.3);
                    ctx.stroke();
                    
                    // Update wave
                    wave.radius += wave.speed;
                    
                    // Remove faded waves
                    if (wave.radius >= wave.maxRadius) {
                        lotus.energyWaves.splice(index, 1);
                    }
                });
                
                // Draw mystical symbols that occasionally appear
                lotus.symbols.forEach(symbol => {
                    if (symbol.opacity > 0) {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(symbol.rotation);
                        ctx.globalAlpha = symbol.opacity;
                        
                        const symbolSize = 20 * scale * symbol.scale;
                        const symbolColor = `rgba(120, 0, 0, ${symbol.opacity})`;
                        ctx.strokeStyle = symbolColor;
                        ctx.lineWidth = 2 * scale;
                        
                        // Different symbol types
                        if (symbol.type === 0) { // Pentagram
                            drawStar(0, 0, symbolSize, 5, 0.5);
                        } else if (symbol.type === 1) { // Circle with inscriptions
                            ctx.beginPath();
                            ctx.arc(0, 0, symbolSize, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Add runes/marks
                            for (let i = 0; i < 8; i++) {
                                const angle = i * Math.PI / 4;
                                const markX = Math.cos(angle) * symbolSize * 0.7;
                                const markY = Math.sin(angle) * symbolSize * 0.7;
                                
                                ctx.beginPath();
                                ctx.moveTo(markX - 5 * scale, markY);
                                ctx.lineTo(markX + 5 * scale, markY);
                                ctx.stroke();
                            }
                        } else { // Triangle with eye
                            ctx.beginPath();
                            ctx.moveTo(0, -symbolSize);
                            ctx.lineTo(symbolSize, symbolSize);
                            ctx.lineTo(-symbolSize, symbolSize);
                            ctx.closePath();
                            ctx.stroke();
                            
                            // Eye in center
                            ctx.beginPath();
                            ctx.arc(0, 0, symbolSize * 0.3, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        
                        ctx.globalAlpha = 1;
                        ctx.restore();
                    }
                });
                
                // Blood drips from center lotus - more visceral
                if (Math.random() < 0.08) {
                    lotus.ripples.push({
                        x: x + (Math.random() - 0.5) * 100 * scale,
                        y: y + (Math.random() - 0.5) * 100 * scale,
                        radius: 3 * scale,
                        maxRadius: 15 * scale,
                        speed: 0.3 * scale,
                        opacity: 0.9,
                        color: '#8a0000',
                        pulsePhase: Math.random() * Math.PI * 2,
                        distort: {
                            amount: 0.3 + Math.random() * 0.3,
                            frequency: 3 + Math.random() * 5,
                            speed: 0.01 + Math.random() * 0.02,
                            timeOffset: Math.random() * 1000
                        }
                    });
                }
            }
            
            // Draw lotus petals with enhanced 3D effect
            for (let i = 0; i < lotus.petals.length; i++) {
                const petal = lotus.petals[i];
                const angle = petal.angle + lotus.rotation;
                
                // Special bloom for center lotus
                let petalBloomFactor = bloomFactor;
                if (isCenter) {
                    // Make center lotus fluctuate more dramatically
                    petalBloomFactor = 0.7 + Math.sin(time / 2000 + i / 3) * 0.3;
                }
                
                // Calculate petal opening based on bloomFactor
                const openAmount = Math.sin(petalBloomFactor * Math.PI) * petal.length;
                
                // Calculate 3D rotation effect
                const rotationX = isCenter ? 
                    Math.sin(time / 3000 + i / lotus.petalCount * Math.PI * 2) * 0.2 : 
                    Math.sin(time / 4000 + petal.offset) * 0.1;
                
                const perspective = 800;
                const zOffset = Math.sin(petal.shimmerPhase + time * petal.shimmerSpeed) * 20;
                const depthScale = perspective / (perspective - zOffset);
                
                // Starting point at the center
                const startX = x;
                const startY = y;
                
                // Control points for the curve with depth effect
                const cp1x = startX + Math.cos(angle) * (openAmount * 0.3) * depthScale;
                const cp1y = startY + Math.sin(angle) * (openAmount * 0.3) * depthScale;
                
                const cp2x = startX + Math.cos(angle) * (openAmount * 0.7) * depthScale;
                const cp2y = startY + Math.sin(angle) * (openAmount * 0.7) * depthScale;
                
                // End point with 3D effect
                const endX = startX + Math.cos(angle) * openAmount * depthScale;
                const endY = startY + Math.sin(angle) * openAmount * depthScale;
                
                // Width control points with 3D effect
                const widthFactor = petal.width * (0.5 + petalBloomFactor * 0.5) * depthScale;
                
                // Draw petal with 3D lighting
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                // Create more realistic petal curve with 3D lighting
                const curve = petal.curve * (1 + rotationX * 0.2);
                
                // First side of petal
                ctx.bezierCurveTo(
                    cp1x - Math.sin(angle) * widthFactor * 0.3, 
                    cp1y + Math.cos(angle) * widthFactor * 0.3,
                    cp2x - Math.sin(angle) * widthFactor * 0.7, 
                    cp2y + Math.cos(angle) * widthFactor * 0.7,
                    endX - Math.sin(angle) * widthFactor * curve, 
                    endY + Math.cos(angle) * widthFactor * curve
                );
                
                // Petal tip curve
                ctx.quadraticCurveTo(
                    endX, 
                    endY,
                    endX + Math.sin(angle) * widthFactor * curve, 
                    endY - Math.cos(angle) * widthFactor * curve
                );
                
                // Second side of petal
                ctx.bezierCurveTo(
                    cp2x + Math.sin(angle) * widthFactor * 0.7, 
                    cp2y - Math.cos(angle) * widthFactor * 0.7,
                    cp1x + Math.sin(angle) * widthFactor * 0.3, 
                    cp1y - Math.cos(angle) * widthFactor * 0.3,
                    startX, startY
                );
                
                // Enhanced gradient for petal with 3D lighting effect
                const lightAngle = Math.PI * 1.2; // Light coming from top-right
                const lightDot = Math.cos(angle - lightAngle);
                const lightIntensity = 0.2 + (lightDot * 0.3);
                
                // 3D height map for texture effect
                const heightVariation = petal.heightMap.reduce((acc, h, idx) => {
                    return acc + h * Math.sin(time / 3000 + angle * 2 + idx);
                }, 0) / petal.heightMap.length * 0.3;
                
                const petalGradient = ctx.createLinearGradient(
                    startX, startY,
                    endX + Math.cos(lightAngle) * widthFactor * 0.5,
                    endY + Math.sin(lightAngle) * widthFactor * 0.5
                );
                
                // Colors based on lotus type with 3D lighting effect
                if (color === 'void') {
                    // For void center lotus - deeper, more ominous black
                    petalGradient.addColorStop(0, `rgba(0, 0, 0, 1)`);
                    petalGradient.addColorStop(0.4, `rgba(10, 0, 0, 0.98)`);
                    petalGradient.addColorStop(0.7, `rgba(20, 0, 0, ${0.95 + heightVariation})`);
                    petalGradient.addColorStop(0.9, `rgba(40, 0, 0, ${0.9 + lightIntensity * 0.3})`);
                    petalGradient.addColorStop(1, `rgba(60, 0, 0, ${0.8 + lightIntensity * 0.3})`);
                } else if (color === 'darkred') {
                    // For dark red lotuses
                    petalGradient.addColorStop(0, `rgba(60, 0, 0, 0.95)`);
                    petalGradient.addColorStop(0.4, `rgba(70, 0, 0, ${0.9 + heightVariation})`);
                    petalGradient.addColorStop(0.7, `rgba(80, 0, 0, ${0.85 + lightIntensity * 0.3})`);
                    petalGradient.addColorStop(0.9, `rgba(100, 0, 0, ${0.8 + lightIntensity * 0.3})`);
                    petalGradient.addColorStop(1, `rgba(120, 0, 0, ${0.75 + lightIntensity * 0.3})`);
                } else {
                    // For blood red lotuses
                    petalGradient.addColorStop(0, `rgba(100, 0, 0, 0.95)`);
                    petalGradient.addColorStop(0.4, `rgba(120, 0, 0, ${0.9 + heightVariation})`);
                    petalGradient.addColorStop(0.7, `rgba(140, 0, 0, ${0.85 + lightIntensity * 0.3})`);
                    petalGradient.addColorStop(0.9, `rgba(160, 0, 0, ${0.8 + lightIntensity * 0.3})`);
                    petalGradient.addColorStop(1, `rgba(180, 0, 0, ${0.75 + lightIntensity * 0.3})`);
                }
                
                ctx.fillStyle = petalGradient;
                ctx.fill();
                
                // Add veins to petals with 3D effect
                const veinColor = color === 'void' ? 
                    `rgba(100, 0, 0, ${0.7 + lightIntensity * 0.3})` : 
                    `rgba(${color === 'darkred' ? '50' : '80'}, 0, 0, ${0.6 + lightIntensity * 0.3})`;
                    
                ctx.strokeStyle = veinColor;
                ctx.lineWidth = 0.5 * scale * depthScale;
                
                // Main vein with 3D curvature
                ctx.beginPath();
                const veinCurveX = Math.sin(angle + Math.PI/2) * rotationX * 10;
                const veinCurveY = Math.cos(angle + Math.PI/2) * rotationX * 10;
                
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(
                    (startX + endX) / 2 + veinCurveX,
                    (startY + endY) / 2 + veinCurveY,
                    endX, endY
                );
                ctx.stroke();
                
                // Side veins with 3D effect
                const veinsCount = 4;
                for (let v = 1; v <= veinsCount; v++) {
                    const vPos = v / (veinsCount + 1);
                    const midX = startX + (endX - startX) * vPos;
                    const midY = startY + (endY - startY) * vPos;
                    
                    const vX = midX + veinCurveX * vPos * (1 - vPos) * 2;
                    const vY = midY + veinCurveY * vPos * (1 - vPos) * 2;
                    
                    const vLength = widthFactor * 0.7 * vPos;
                    
                    ctx.beginPath();
                    ctx.moveTo(vX, vY);
                    ctx.lineTo(
                        vX + Math.sin(angle + Math.PI/4 + rotationX) * vLength,
                        vY - Math.cos(angle + Math.PI/4 + rotationX) * vLength
                    );
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(vX, vY);
                    ctx.lineTo(
                        vX - Math.sin(angle - Math.PI/4 - rotationX) * vLength,
                        vY + Math.cos(angle - Math.PI/4 - rotationX) * vLength
                    );
                    ctx.stroke();
                }
                
                // Add subtle highlight to petal edges
                const edgeHighlight = color === 'void' ? 
                    `rgba(150, 0, 0, ${0.3 + lightIntensity * 0.3})` : 
                    `rgba(220, 50, 50, ${0.2 + lightIntensity * 0.3})`;
                    
                ctx.strokeStyle = edgeHighlight;
                ctx.lineWidth = 0.8 * scale * depthScale;
                ctx.stroke();
                
                // Add subtle texture pattern to petal surface
                if (isCenter) {
                    ctx.save();
                    ctx.clip(); // Keep texture inside petal
                    
                    // Draw branching vein patterns
                    const branchPattern = (x, y, angle, length, depth) => {
                        if (depth <= 0) return;
                        
                        const endX = x + Math.cos(angle) * length;
                        const endY = y + Math.sin(angle) * length;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(endX, endY);
                        ctx.strokeStyle = `rgba(70, 0, 0, ${0.1 + depth * 0.05})`;
                        ctx.lineWidth = depth * 0.3 * scale;
                        ctx.stroke();
                        
                        const branchAngle = 0.5; // About 30 degrees
                        branchPattern(endX, endY, angle + branchAngle, length * 0.7, depth - 1);
                        branchPattern(endX, endY, angle - branchAngle, length * 0.7, depth - 1);
                    };
                    
                    if (Math.random() < 0.5) {
                        branchPattern(
                            startX + (endX - startX) * 0.3,
                            startY + (endY - startY) * 0.3,
                            angle + (Math.random() - 0.5) * 0.3,
                            petal.length * 0.4 * scale,
                            2
                        );
                    }
                    
                    ctx.restore();
                }
                
                // Add blood drops/marks on petals
                if ((isCenter && Math.random() < 0.07) || Math.random() < 0.01) {
                    const dropX = startX + (endX - startX) * (0.4 + Math.random() * 0.5);
                    const dropY = startY + (endY - startY) * (0.4 + Math.random() * 0.5);
                    const dropSize = (isCenter ? 3 : 2) + Math.random() * (isCenter ? 3 : 2);
                    
                    // Blood droplet with volume
                    const dropGradient = ctx.createRadialGradient(
                        dropX, dropY, 0,
                        dropX, dropY, dropSize * scale
                    );
                    dropGradient.addColorStop(0, 'rgba(180, 0, 0, 0.9)');
                    dropGradient.addColorStop(0.7, 'rgba(120, 0, 0, 0.8)');
                    dropGradient.addColorStop(1, 'rgba(80, 0, 0, 0.7)');
                    
                    ctx.beginPath();
                    ctx.arc(dropX, dropY, dropSize * scale, 0, Math.PI * 2);
                    ctx.fillStyle = dropGradient;
                    ctx.fill();
                    
                    // Reflective highlight
                    ctx.beginPath();
                    ctx.arc(
                        dropX - dropSize * 0.3 * scale, 
                        dropY - dropSize * 0.3 * scale, 
                        dropSize * 0.4 * scale, 
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = "rgba(255, 50, 50, 0.4)";
                    ctx.fill();
                    
                    // Blood drip effect
                    if (Math.random() < 0.7) {
                        const dripLength = 5 + Math.random() * (isCenter ? 20 : 10);
                        const dripWidth = (1 + Math.random() * 1.5) * scale;
                        const dripAngle = angle + (Math.random() - 0.5) * 0.5;
                        
                        // Create a curving drip
                        ctx.beginPath();
                        ctx.moveTo(dropX, dropY);
                        
                        const cp1x = dropX + Math.cos(dripAngle) * dripLength * 0.5;
                        const cp1y = dropY + Math.sin(dripAngle) * dripLength * 0.5 + dripLength * 0.2;
                        const dripEndX = dropX + Math.cos(dripAngle) * dripLength;
                        const dripEndY = dropY + Math.sin(dripAngle) * dripLength + dripLength * 0.3;
                        
                        ctx.quadraticCurveTo(cp1x, cp1y, dripEndX, dripEndY);
                        
                        // Drip gradient
                        const dripGradient = ctx.createLinearGradient(dropX, dropY, dripEndX, dripEndY);
                        dripGradient.addColorStop(0, 'rgba(150, 0, 0, 0.8)');
                        dripGradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                        
                        ctx.strokeStyle = dripGradient;
                        ctx.lineWidth = dripWidth;
                        ctx.stroke();
                    }
                }
            }
            
            // Draw lotus center with more detail and depth
            ctx.beginPath();
            ctx.arc(x, y, 20 * scale, 0, Math.PI * 2);
            
            let centerColor1, centerColor2, centerColor3;
            
            if (color === 'void') {
                centerColor1 = 'rgba(0, 0, 0, 1)';
                centerColor2 = 'rgba(20, 0, 0, 0.95)';
                centerColor3 = 'rgba(40, 0, 0, 0.9)';
            } else if (color === 'darkred') {
                centerColor1 = 'rgba(50, 0, 0, 1)';
                centerColor2 = 'rgba(30, 0, 0, 0.95)';
                centerColor3 = 'rgba(10, 0, 0, 0.9)';
            } else {
                centerColor1 = 'rgba(80, 0, 0, 1)';
                centerColor2 = 'rgba(40, 0, 0, 0.95)';
                centerColor3 = 'rgba(20, 0, 0, 0.9)';
            }
            
            const centerGradient = ctx.createRadialGradient(
                x - 5 * scale, y - 5 * scale, 5 * scale, // Offset for 3D lighting
                x, y, 20 * scale
            );
            centerGradient.addColorStop(0, centerColor1);
            centerGradient.addColorStop(0.7, centerColor2);
            centerGradient.addColorStop(1, centerColor3);
            ctx.fillStyle = centerGradient;
            ctx.fill();
            
            // Add texture to center with 3D effect
            const dotColor = color === 'void' ? 
                'rgba(100, 0, 0, 0.4)' : 
                'rgba(200, 50, 50, 0.25)';
                
            ctx.fillStyle = dotColor;
            
            // Create spiral pattern in center
            const spiralArms = 5;
            const spiralRotation = time / 10000;
            
            for (let arm = 0; arm < spiralArms; arm++) {
                const baseAngle = (arm / spiralArms) * Math.PI * 2 + spiralRotation;
                
                for (let i = 0; i < 8; i++) {
                    const dist = (i / 8) * 20 * scale;
                    const dotAngle = baseAngle + (i / 8) * Math.PI * 0.5;
                    const dotSize = (3 - (i / 8) * 2) * scale;
                    
                    ctx.beginPath();
                    ctx.arc(
                        x + Math.cos(dotAngle) * dist,
                        y + Math.sin(dotAngle) * dist,
                        dotSize,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            
            // Draw ripples with distortion effects
            lotus.ripples.forEach((ripple, index) => {
                ctx.beginPath();
                
                if (ripple.distort) {
                    // Create distorted, unsettling ripple
                    const segments = 36;
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        const distortAmount = ripple.distort.amount * Math.sin(
                            angle * ripple.distort.frequency + 
                            time * ripple.distort.speed + 
                            (ripple.distort.timeOffset || 0)
                        );
                        
                        const radiusOffset = ripple.radius * (1 + distortAmount);
                        const px = ripple.x + Math.cos(angle) * radiusOffset;
                        const py = ripple.y + Math.sin(angle) * radiusOffset;
                        
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                } else {
                    ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                }
                
                // Pulsating ripple effect
                const pulseEffect = ripple.pulsePhase ? 
                    (0.7 + Math.sin(time / 500 + ripple.pulsePhase) * 0.3) : 1;
                    
                ctx.lineWidth = (1.5 * scale) * pulseEffect;
                ctx.globalAlpha = ripple.opacity * pulseEffect;
                
                // Custom color for ominous ripples
                if (ripple.color) {
                    ctx.strokeStyle = ripple.color;
                } else {
                    const baseColor = lotus.isCenter ? '120, 0, 0' : 
                        lotus.color === 'darkred' ? '80, 0, 0' : '150, 20, 20';
                    ctx.strokeStyle = `rgba(${baseColor}, ${ripple.opacity})`;
                }
                
                ctx.stroke();
                
                // Update ripple
                ripple.radius += ripple.speed;
                ripple.opacity -= 0.004;
                
                // Remove faded ripples
                if (ripple.opacity <= 0 || ripple.radius >= ripple.maxRadius) {
                    lotus.ripples.splice(index, 1);
                    
                    // Create new ripple to replace the old one
                    if ((Math.random() > 0.3 || lotus.isCenter) && lotus.ripples.length < 20) {
                        createRipple(lotus, lotus.isCenter && Math.random() > 0.5);
                    }
                }
            });
            
            ctx.globalAlpha = 1;
        }
        
        // Helper function to draw mystical star shapes
        function drawStar(x, y, radius, points, inset) {
            ctx.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points;
                const r = i % 2 === 0 ? radius : radius * inset;
                const px = x + r * Math.sin(angle);
                const py = y - r * Math.cos(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        }
        
        // Start animation with time tracking
        let time = 0;
        animate();
    }
    </script>
</body>
</html>